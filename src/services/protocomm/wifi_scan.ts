// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v6.33.4
// source: wifi_scan.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Status, statusFromJSON, statusToJSON } from "./constants";
import { WifiAuthMode, wifiAuthModeFromJSON, wifiAuthModeToJSON } from "./wifi_constants";

export const protobufPackage = "";

export enum WiFiScanMsgType {
  TypeCmdScanStart = 0,
  TypeRespScanStart = 1,
  TypeCmdScanStatus = 2,
  TypeRespScanStatus = 3,
  TypeCmdScanResult = 4,
  TypeRespScanResult = 5,
  UNRECOGNIZED = -1,
}

export function wiFiScanMsgTypeFromJSON(object: any): WiFiScanMsgType {
  switch (object) {
    case 0:
    case "TypeCmdScanStart":
      return WiFiScanMsgType.TypeCmdScanStart;
    case 1:
    case "TypeRespScanStart":
      return WiFiScanMsgType.TypeRespScanStart;
    case 2:
    case "TypeCmdScanStatus":
      return WiFiScanMsgType.TypeCmdScanStatus;
    case 3:
    case "TypeRespScanStatus":
      return WiFiScanMsgType.TypeRespScanStatus;
    case 4:
    case "TypeCmdScanResult":
      return WiFiScanMsgType.TypeCmdScanResult;
    case 5:
    case "TypeRespScanResult":
      return WiFiScanMsgType.TypeRespScanResult;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WiFiScanMsgType.UNRECOGNIZED;
  }
}

export function wiFiScanMsgTypeToJSON(object: WiFiScanMsgType): string {
  switch (object) {
    case WiFiScanMsgType.TypeCmdScanStart:
      return "TypeCmdScanStart";
    case WiFiScanMsgType.TypeRespScanStart:
      return "TypeRespScanStart";
    case WiFiScanMsgType.TypeCmdScanStatus:
      return "TypeCmdScanStatus";
    case WiFiScanMsgType.TypeRespScanStatus:
      return "TypeRespScanStatus";
    case WiFiScanMsgType.TypeCmdScanResult:
      return "TypeCmdScanResult";
    case WiFiScanMsgType.TypeRespScanResult:
      return "TypeRespScanResult";
    case WiFiScanMsgType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CmdScanStart {
  blocking: boolean;
  passive: boolean;
  groupChannels: number;
  periodMs: number;
}

export interface RespScanStart {
}

export interface CmdScanStatus {
}

export interface RespScanStatus {
  scanFinished: boolean;
  resultCount: number;
}

export interface CmdScanResult {
  startIndex: number;
  count: number;
}

export interface WiFiScanResult {
  ssid: Uint8Array;
  channel: number;
  rssi: number;
  bssid: Uint8Array;
  auth: WifiAuthMode;
}

export interface RespScanResult {
  entries: WiFiScanResult[];
}

export interface WiFiScanPayload {
  msg: WiFiScanMsgType;
  status: Status;
  cmdScanStart?: CmdScanStart | undefined;
  respScanStart?: RespScanStart | undefined;
  cmdScanStatus?: CmdScanStatus | undefined;
  respScanStatus?: RespScanStatus | undefined;
  cmdScanResult?: CmdScanResult | undefined;
  respScanResult?: RespScanResult | undefined;
}

function createBaseCmdScanStart(): CmdScanStart {
  return { blocking: false, passive: false, groupChannels: 0, periodMs: 0 };
}

export const CmdScanStart: MessageFns<CmdScanStart> = {
  encode(message: CmdScanStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blocking !== false) {
      writer.uint32(8).bool(message.blocking);
    }
    if (message.passive !== false) {
      writer.uint32(16).bool(message.passive);
    }
    if (message.groupChannels !== 0) {
      writer.uint32(24).uint32(message.groupChannels);
    }
    if (message.periodMs !== 0) {
      writer.uint32(32).uint32(message.periodMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CmdScanStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCmdScanStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.blocking = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.passive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupChannels = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.periodMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CmdScanStart {
    return {
      blocking: isSet(object.blocking) ? globalThis.Boolean(object.blocking) : false,
      passive: isSet(object.passive) ? globalThis.Boolean(object.passive) : false,
      groupChannels: isSet(object.groupChannels)
        ? globalThis.Number(object.groupChannels)
        : isSet(object.group_channels)
        ? globalThis.Number(object.group_channels)
        : 0,
      periodMs: isSet(object.periodMs)
        ? globalThis.Number(object.periodMs)
        : isSet(object.period_ms)
        ? globalThis.Number(object.period_ms)
        : 0,
    };
  },

  toJSON(message: CmdScanStart): unknown {
    const obj: any = {};
    if (message.blocking !== false) {
      obj.blocking = message.blocking;
    }
    if (message.passive !== false) {
      obj.passive = message.passive;
    }
    if (message.groupChannels !== 0) {
      obj.groupChannels = Math.round(message.groupChannels);
    }
    if (message.periodMs !== 0) {
      obj.periodMs = Math.round(message.periodMs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CmdScanStart>, I>>(base?: I): CmdScanStart {
    return CmdScanStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CmdScanStart>, I>>(object: I): CmdScanStart {
    const message = createBaseCmdScanStart();
    message.blocking = object.blocking ?? false;
    message.passive = object.passive ?? false;
    message.groupChannels = object.groupChannels ?? 0;
    message.periodMs = object.periodMs ?? 0;
    return message;
  },
};

function createBaseRespScanStart(): RespScanStart {
  return {};
}

export const RespScanStart: MessageFns<RespScanStart> = {
  encode(_: RespScanStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespScanStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespScanStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RespScanStart {
    return {};
  },

  toJSON(_: RespScanStart): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<RespScanStart>, I>>(base?: I): RespScanStart {
    return RespScanStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespScanStart>, I>>(_: I): RespScanStart {
    const message = createBaseRespScanStart();
    return message;
  },
};

function createBaseCmdScanStatus(): CmdScanStatus {
  return {};
}

export const CmdScanStatus: MessageFns<CmdScanStatus> = {
  encode(_: CmdScanStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CmdScanStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCmdScanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CmdScanStatus {
    return {};
  },

  toJSON(_: CmdScanStatus): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<CmdScanStatus>, I>>(base?: I): CmdScanStatus {
    return CmdScanStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CmdScanStatus>, I>>(_: I): CmdScanStatus {
    const message = createBaseCmdScanStatus();
    return message;
  },
};

function createBaseRespScanStatus(): RespScanStatus {
  return { scanFinished: false, resultCount: 0 };
}

export const RespScanStatus: MessageFns<RespScanStatus> = {
  encode(message: RespScanStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scanFinished !== false) {
      writer.uint32(8).bool(message.scanFinished);
    }
    if (message.resultCount !== 0) {
      writer.uint32(16).uint32(message.resultCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespScanStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespScanStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scanFinished = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.resultCount = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RespScanStatus {
    return {
      scanFinished: isSet(object.scanFinished)
        ? globalThis.Boolean(object.scanFinished)
        : isSet(object.scan_finished)
        ? globalThis.Boolean(object.scan_finished)
        : false,
      resultCount: isSet(object.resultCount)
        ? globalThis.Number(object.resultCount)
        : isSet(object.result_count)
        ? globalThis.Number(object.result_count)
        : 0,
    };
  },

  toJSON(message: RespScanStatus): unknown {
    const obj: any = {};
    if (message.scanFinished !== false) {
      obj.scanFinished = message.scanFinished;
    }
    if (message.resultCount !== 0) {
      obj.resultCount = Math.round(message.resultCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RespScanStatus>, I>>(base?: I): RespScanStatus {
    return RespScanStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespScanStatus>, I>>(object: I): RespScanStatus {
    const message = createBaseRespScanStatus();
    message.scanFinished = object.scanFinished ?? false;
    message.resultCount = object.resultCount ?? 0;
    return message;
  },
};

function createBaseCmdScanResult(): CmdScanResult {
  return { startIndex: 0, count: 0 };
}

export const CmdScanResult: MessageFns<CmdScanResult> = {
  encode(message: CmdScanResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).uint32(message.startIndex);
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CmdScanResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCmdScanResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CmdScanResult {
    return {
      startIndex: isSet(object.startIndex)
        ? globalThis.Number(object.startIndex)
        : isSet(object.start_index)
        ? globalThis.Number(object.start_index)
        : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: CmdScanResult): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CmdScanResult>, I>>(base?: I): CmdScanResult {
    return CmdScanResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CmdScanResult>, I>>(object: I): CmdScanResult {
    const message = createBaseCmdScanResult();
    message.startIndex = object.startIndex ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseWiFiScanResult(): WiFiScanResult {
  return { ssid: new Uint8Array(0), channel: 0, rssi: 0, bssid: new Uint8Array(0), auth: 0 };
}

export const WiFiScanResult: MessageFns<WiFiScanResult> = {
  encode(message: WiFiScanResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ssid.length !== 0) {
      writer.uint32(10).bytes(message.ssid);
    }
    if (message.channel !== 0) {
      writer.uint32(16).uint32(message.channel);
    }
    if (message.rssi !== 0) {
      writer.uint32(24).int32(message.rssi);
    }
    if (message.bssid.length !== 0) {
      writer.uint32(34).bytes(message.bssid);
    }
    if (message.auth !== 0) {
      writer.uint32(40).int32(message.auth);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WiFiScanResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWiFiScanResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ssid = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channel = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rssi = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bssid = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.auth = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WiFiScanResult {
    return {
      ssid: isSet(object.ssid) ? bytesFromBase64(object.ssid) : new Uint8Array(0),
      channel: isSet(object.channel) ? globalThis.Number(object.channel) : 0,
      rssi: isSet(object.rssi) ? globalThis.Number(object.rssi) : 0,
      bssid: isSet(object.bssid) ? bytesFromBase64(object.bssid) : new Uint8Array(0),
      auth: isSet(object.auth) ? wifiAuthModeFromJSON(object.auth) : 0,
    };
  },

  toJSON(message: WiFiScanResult): unknown {
    const obj: any = {};
    if (message.ssid.length !== 0) {
      obj.ssid = base64FromBytes(message.ssid);
    }
    if (message.channel !== 0) {
      obj.channel = Math.round(message.channel);
    }
    if (message.rssi !== 0) {
      obj.rssi = Math.round(message.rssi);
    }
    if (message.bssid.length !== 0) {
      obj.bssid = base64FromBytes(message.bssid);
    }
    if (message.auth !== 0) {
      obj.auth = wifiAuthModeToJSON(message.auth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WiFiScanResult>, I>>(base?: I): WiFiScanResult {
    return WiFiScanResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WiFiScanResult>, I>>(object: I): WiFiScanResult {
    const message = createBaseWiFiScanResult();
    message.ssid = object.ssid ?? new Uint8Array(0);
    message.channel = object.channel ?? 0;
    message.rssi = object.rssi ?? 0;
    message.bssid = object.bssid ?? new Uint8Array(0);
    message.auth = object.auth ?? 0;
    return message;
  },
};

function createBaseRespScanResult(): RespScanResult {
  return { entries: [] };
}

export const RespScanResult: MessageFns<RespScanResult> = {
  encode(message: RespScanResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      WiFiScanResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RespScanResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRespScanResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(WiFiScanResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RespScanResult {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => WiFiScanResult.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RespScanResult): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => WiFiScanResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RespScanResult>, I>>(base?: I): RespScanResult {
    return RespScanResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RespScanResult>, I>>(object: I): RespScanResult {
    const message = createBaseRespScanResult();
    message.entries = object.entries?.map((e) => WiFiScanResult.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWiFiScanPayload(): WiFiScanPayload {
  return {
    msg: 0,
    status: 0,
    cmdScanStart: undefined,
    respScanStart: undefined,
    cmdScanStatus: undefined,
    respScanStatus: undefined,
    cmdScanResult: undefined,
    respScanResult: undefined,
  };
}

export const WiFiScanPayload: MessageFns<WiFiScanPayload> = {
  encode(message: WiFiScanPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msg !== 0) {
      writer.uint32(8).int32(message.msg);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.cmdScanStart !== undefined) {
      CmdScanStart.encode(message.cmdScanStart, writer.uint32(82).fork()).join();
    }
    if (message.respScanStart !== undefined) {
      RespScanStart.encode(message.respScanStart, writer.uint32(90).fork()).join();
    }
    if (message.cmdScanStatus !== undefined) {
      CmdScanStatus.encode(message.cmdScanStatus, writer.uint32(98).fork()).join();
    }
    if (message.respScanStatus !== undefined) {
      RespScanStatus.encode(message.respScanStatus, writer.uint32(106).fork()).join();
    }
    if (message.cmdScanResult !== undefined) {
      CmdScanResult.encode(message.cmdScanResult, writer.uint32(114).fork()).join();
    }
    if (message.respScanResult !== undefined) {
      RespScanResult.encode(message.respScanResult, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WiFiScanPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWiFiScanPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msg = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cmdScanStart = CmdScanStart.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.respScanStart = RespScanStart.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.cmdScanStatus = CmdScanStatus.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.respScanStatus = RespScanStatus.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.cmdScanResult = CmdScanResult.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.respScanResult = RespScanResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WiFiScanPayload {
    return {
      msg: isSet(object.msg) ? wiFiScanMsgTypeFromJSON(object.msg) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      cmdScanStart: isSet(object.cmdScanStart)
        ? CmdScanStart.fromJSON(object.cmdScanStart)
        : isSet(object.cmd_scan_start)
        ? CmdScanStart.fromJSON(object.cmd_scan_start)
        : undefined,
      respScanStart: isSet(object.respScanStart)
        ? RespScanStart.fromJSON(object.respScanStart)
        : isSet(object.resp_scan_start)
        ? RespScanStart.fromJSON(object.resp_scan_start)
        : undefined,
      cmdScanStatus: isSet(object.cmdScanStatus)
        ? CmdScanStatus.fromJSON(object.cmdScanStatus)
        : isSet(object.cmd_scan_status)
        ? CmdScanStatus.fromJSON(object.cmd_scan_status)
        : undefined,
      respScanStatus: isSet(object.respScanStatus)
        ? RespScanStatus.fromJSON(object.respScanStatus)
        : isSet(object.resp_scan_status)
        ? RespScanStatus.fromJSON(object.resp_scan_status)
        : undefined,
      cmdScanResult: isSet(object.cmdScanResult)
        ? CmdScanResult.fromJSON(object.cmdScanResult)
        : isSet(object.cmd_scan_result)
        ? CmdScanResult.fromJSON(object.cmd_scan_result)
        : undefined,
      respScanResult: isSet(object.respScanResult)
        ? RespScanResult.fromJSON(object.respScanResult)
        : isSet(object.resp_scan_result)
        ? RespScanResult.fromJSON(object.resp_scan_result)
        : undefined,
    };
  },

  toJSON(message: WiFiScanPayload): unknown {
    const obj: any = {};
    if (message.msg !== 0) {
      obj.msg = wiFiScanMsgTypeToJSON(message.msg);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.cmdScanStart !== undefined) {
      obj.cmdScanStart = CmdScanStart.toJSON(message.cmdScanStart);
    }
    if (message.respScanStart !== undefined) {
      obj.respScanStart = RespScanStart.toJSON(message.respScanStart);
    }
    if (message.cmdScanStatus !== undefined) {
      obj.cmdScanStatus = CmdScanStatus.toJSON(message.cmdScanStatus);
    }
    if (message.respScanStatus !== undefined) {
      obj.respScanStatus = RespScanStatus.toJSON(message.respScanStatus);
    }
    if (message.cmdScanResult !== undefined) {
      obj.cmdScanResult = CmdScanResult.toJSON(message.cmdScanResult);
    }
    if (message.respScanResult !== undefined) {
      obj.respScanResult = RespScanResult.toJSON(message.respScanResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WiFiScanPayload>, I>>(base?: I): WiFiScanPayload {
    return WiFiScanPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WiFiScanPayload>, I>>(object: I): WiFiScanPayload {
    const message = createBaseWiFiScanPayload();
    message.msg = object.msg ?? 0;
    message.status = object.status ?? 0;
    message.cmdScanStart = (object.cmdScanStart !== undefined && object.cmdScanStart !== null)
      ? CmdScanStart.fromPartial(object.cmdScanStart)
      : undefined;
    message.respScanStart = (object.respScanStart !== undefined && object.respScanStart !== null)
      ? RespScanStart.fromPartial(object.respScanStart)
      : undefined;
    message.cmdScanStatus = (object.cmdScanStatus !== undefined && object.cmdScanStatus !== null)
      ? CmdScanStatus.fromPartial(object.cmdScanStatus)
      : undefined;
    message.respScanStatus = (object.respScanStatus !== undefined && object.respScanStatus !== null)
      ? RespScanStatus.fromPartial(object.respScanStatus)
      : undefined;
    message.cmdScanResult = (object.cmdScanResult !== undefined && object.cmdScanResult !== null)
      ? CmdScanResult.fromPartial(object.cmdScanResult)
      : undefined;
    message.respScanResult = (object.respScanResult !== undefined && object.respScanResult !== null)
      ? RespScanResult.fromPartial(object.respScanResult)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
